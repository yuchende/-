---

---

[TOC]



参考地址：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/

阅读须知：代码在最后

------

###### 题目1：两数和||输入有序数组

------

 题目描述       

​		给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

​		函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

​		说明:

​		返回的下标值（index1 和 index2）不是从零开始的。
​		你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

​		示例:

​		输入: numbers = [2, 7, 11, 15], target = 9
​		输出: [1,2]
​		解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

------

思路：

```xml
      双指针缩小解空间

      求最大值 + 最小值=目标值   的两个元素

      特性： 最大值+最小值< 目标值  那么就可以舍弃最小值。应为最大值加上最小值都小于target，那么其他最大值加上最小值也是依然小于的。
            故舍弃最小值。相反舍去最大值。
      这样极大的缩小了解空间。
```

​      


       

    


> - [ ] ##### 题目2：最大值最小值之差不超过x

 题目描述：

​     给出一个序列包含n个正整数的序列A，你可以从中删除若干个数，使得剩下的数字中的最大值和最小值之差	  不超过x，请问最少删除多少个数字。

  输入第一行仅包含两个正整数n和x，表示给出的序列的长度和给定的正整数。(1<=n<=1000,1<=x<=10000)
   接下来一行有n个正整数，即这个序列，中间用空格隔开。(1<=a_i<=10000)

   输出仅包含一个整数，表示最少删除的数字的数量
   输入
   5 2
   2 1 3 2 5
   输出
   1

思路:      

```xml
  排序后，采用左右指针方法。
  是否排除左右端点的值，来求最终的长度。
  
   同类型的题：左右指针问题 

​       两数之差小于target值,        有序数组中，相邻2个数之差是小的。
​       即  a_max  - a_min  < target 
​       a1  a2 a3 a4 a5 a6   递增序列
​       要求   删除最少量的数 使之满足max - min <=target。 求出删除了几个数
   
   
   
   如果按照暴力破解法那么,时间复杂度在  n平方
   那么思路  a6 - a5   a6 - a4  a6 - a3
   
   如何缩小解空间？
    a6 - a5 最大值 - 第二大值 > target  那么第二大值 前面都是比第二大值小的，差值只会越大，最     小的都不满足 <=target
    那么 min_D_value > target   最小值都大于target  那么a6与a5前面的数之差都会是 > target
    删除a6
   
    相同的a2 - a1 >target  那么a1也该舍弃。应为a2后面的函数是递增的。
```

​     

- [ ] > - [ ] ##### 题3:长度最小子数组

------

1. 题目描述

​	给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如	果不存在符合条件的连续子数组，返回 0。

​	示例: 

​	输入: s = 7, nums = [2,3,1,2,4,3]
​	输出: 2
​	解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。

​	进阶:	如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。

------

2. 思路：

```xml
 1. 双指针方法，滑动窗口找子序列。
 2. 每次找一个特定窗口，这个窗口内部sum刚好满足 sum < s 什么是刚好？ 就是窗口左边加一个num或窗口
    右边加一个num都不满足  sum < s  满足sum >= s
 3. 利用两个指针确定窗口的边界下表  [i,j]
    每次窗口满足  sum >= s 的时候 就更新最小长度。


步骤：
	初始化: i=0 j=0
	1. j++,   aleft +...+aj = sum  直到sum>=s  更新最小长度
	2. i++,  ai+....+aj = sum 直到sum < s 每次i++ 都更新最小长度。当sum < s 重复1

	public int minSubArrayLen(int s, int[] nums) {
        int minLen = Integer.MAX_VALUE;
        int sum = 0;
        int i = 0;
        for(int j=0;j<nums.length;j++){
            sum+=nums[j];
            while(sum>=s){
                minLen = Math.min(minLen,j-i+1);
                sum-=nums[i++];
            }
        }
        return minLen==Integer.MAX_VALUE ? 0:minLen;
    }
	滑动窗口的代码经典代码
```



> - [ ] ##### 总结: 双指针的模板

```xml
1. 左右指针，2个指针分别向对方移动，解决最大数与最小数的差值问题,和 和等于某个x问题。
2. 快慢指针，滑动的窗口，2个指针向相同方向移动，移动速度不同，可以看作是一个。

1.两个指针的移动方向不同可以解决不同的问题


```



题目2:

```java
 public class Main{
  //这里省略主函数
  
  public static int cal(int[] array,int x){
    Arrays.sort(array);
    int left = 0,right = array.length-1;
    int result = 0;
    boolean secondCondition = false ;
    while(left<=right){
        int chazhi = array[right] - array[left];
        if(chazhi<=x){
          break;
        }else{
            int leftMulsValue = array[left+1]-array[left];
            int rightMulsValue = array[right]-array[right-1];
            if(leftMulsValue > target){
              left++;//舍弃左边array[left]
              result++;
            }
            if(rightMulsValue > target){
              right--;
              result++;
            }
            //如果两种都不满足那么即如下
            //就要找到最小删除的数
            if(leftMulsValue<=target && rightMulsValue<=target){
                secondCondition = true;
                break;
            }     
        }
    }
    if(secondCondition == true){
        int l = left;
        int r = right;
        int lenLeft = 1,lenRight = 1;
        while(((l+1)<right)&&(array[l+1] - array[left] <= target)){
          l++;
          lenLeft++;
        }
        while(((r-1)>left)&&(array[right] - array[r-1])<=target){
          r--;
          lenRight++;
        }
        if(lenLeft<lenRight){
          result = result + (l - left + 1);
        }else{
          result = result + (right - r + 1);
        }
    }
    return result;
  }
 
 }
```


题1  代码：

```java
public int[] twoSum(int[] numbers, int target) {
         int left = 0;
         int right = numbers.length-1;
         while(left<right){
             int sum = numbers[left]+numbers[right];
             if(sum==target){
                 return new int[]{++left,++right};
             }
             if(sum < target){
                 left++;
             }
             if(sum > target){
                 right--;
             }
         }
         return new int[]{-1,-1};
      }
```


